---
title: Redis Persistence
cover: '/cover/Fossil-Leaf.jpeg'
date: 2023-12-12
tags: ['Redis']
---

As an in-memory database, Redis still provides persistence mechanisms for two primary purposes:

- Safety: Ensuring data is not lost in the event of process crashes.
- Backup: Facilitating data migration and quick recovery.

Redis provides two main persistence mechanisms:

- RDB Snapshot:Complete state of the database at a certain point in time, storing key-value pairs.
- AOF Log: Operations that change the state of the database, storing commands.


[comment]:summary

## RDB Snapshot

There are two ways to generate RDB snapshots:
- Regularly by the service process.
- Manually by executing the `SAVE` or `BGSAVE` commands.


### Regular Generation

Users can control the automatic generation of RDB snapshots by setting **save points**:
```text
save 900 1    # At least 1 key change in the last 15 minutes
save 300 10   # At least 10 key changes in the last 5 minutes
save 60 10000 # At least 10000 key changes in the last 1 minute
```

```c
struct saveparam {
    time_t seconds; // Number of seconds
    int changes;    // Number of changes
};

struct redisServer {
    // ...
    struct saveparam *saveparams;   /* RDB save point array */
    int saveparamslen;              /* Number of save points */
    long long dirty;                /* Number of changes since the last snapshot */
    time_t lastsave;                /* UNIX timestamp of the last snapshot taken */
}
```

```text
+---------------+
|  redisServer  |
+---------------+    +---------------+---------------+---------------+
|  saveparams   | -> | saveparams[0] | saveparams[1] | saveparams[2] |
+---------------+    +---------------+---------------+---------------+
| saveparamslen |    |    seconds    |    seconds    |    seconds    |
|       3       |    |      900      |      300      |       60      |
+---------------+    +---------------+---------------+---------------+
|     dirty     |    |    changes    |    changes    |    changes    |
|      120      |    |       1       |       10      |     10000     |
+---------------+    +---------------+---------------+---------------+
|   lastsave    |
|  1378270800   |
+---------------+     
```

Automatic saving process:
1. Every time a database modification command is executed, the `dirty` counter records the number of changes caused by that command.
2. Redis's periodic task `serverCron` periodically checks if the save point conditions are met.

```c
int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) {
    // ...
    for (j = 0; j < server.saveparamslen; j++) {
        struct saveparam *sp = server.saveparams+j;
        if (server.dirty >= sp->changes && // Check if the number of changes is enough
            server.unixtime-server.lastsave > sp->seconds) // Check the latest snapshot time
        {
             // If the current state meets the savepoint settings, print the log and start executing BGSAVE
            serverLog(LL_NOTICE,"%d changes in %d seconds. Saving...", sp->changes, (int)sp->seconds);
            // ...
             // Trigger BGSAVE
            rdbSaveBackground(server.rdb_filename,rsiptr);
            break;
        }
    }
}
```

### Manual Backup

To avoid performance fluctuations during peak traffic, the automatic snapshot generation is often disabled in production environments. 
To ensure data safety, operations personnel use scheduled scripts to execute the `BGSAVE` command to back up Redis data when the system is idle.
```c
int rdbSaveBackground(char *filename, rdbSaveInfo *rsi) {
    // ...
    if ((childpid = redisFork(CHILD_TYPE_RDB)) == 0) { // Fork child process
        /* The child process start generating RDB snapshots... */
        int retval = rdbSave(filename,rsi);
        // ...
    } else {
         /* The main process returns directly without blocking */
        serverLog(LL_NOTICE,"Background saving started by pid %d",childpid);
        updateDictResizePolicy();  // During the snapshot generation, prohibit rehash operations on dict
        // ...
        return C_OK;
    }
}
```

The RDB file is generated by the child process. 
The **copy-on-write** optimization feature of the operating system determines that the memory between the parent and child processes is logically independent.
Therefore, any modification from the main process will not be included in the RDB file, which ensures the consistency of the state recorded by the RDB.

### RDB Files

The RDB snapshot is a binary file:

```text
# RDB files for n databases
+-------+------------+-------+-----+-------+-----+-----------+
| REDIS | db_version | db[0] | ... | db[n] | EOF | check_sum |
+-------+------------+-------+-----+-------+-----+-----------+
  
# Each database contains arbitrary key-value pairs
+-------+    +----------+---+------------+-----+------------+
| db[0] | => | SELECTDB | 0 | kv_pair[0] | ... | kv_pair[n] | 
+-------+    +----------+---+------------+-----+------------+
  
# Key-value pairs, with constant TYPE indicating the encoding type of the value
+---------+    +------+-----+-------+
| kv_pair | => | TYPE | key | value |
+---------+    +------+-----+-------+
  
# Key-value pairs with expiration time, with constant EXPIRETIME_MS followed by an 8-byte timestamp
+------------------+    +---------------+--------------+------+-----+-------+
| kv_pair_with_ttl | => | EXPIRETIME_MS | ms_timestamp | TYPE | key | value |
+------------------+    +---------------+--------------+------+-----+-------+
```

The RDB snapshot stores the complete state of the database in compact format, making it suitable for data backup:

- Convenient for transmission over the network to remote data centers for disaster recovery.
- Using the `RESTORE` command to load the RDB snapshot can initialize data or perform emergency rollbacks.


## AOF Log

The process of generating RDB snapshots is time-consuming and cannot be performed frequently with `BGSAVE`. 
However, if state changes are not persisted in time, a process crash could result in a loss of significant amounts of unpersisted data.

To avoid the overhead of full backups, Redis supports persisting state changes to the AOF log incrementally, reducing pressure on disk I/O.

As the AOF log is written by the main thread, the flushing strategy significantly affects Redis's performance. 
The following configuration options control this behavior:

```bash
appendonly no         # Enable AOF

# Flushing policy
# always: Flush immediately after each change
# everysec: Flush once per second
# no: Let the OS decide when to flush
appendfsync everysec
```

```c
struct redisServer {
    // ...
    int aof_enabled;                /* AOF switch */
    int aof_state;                  /* AOF state (on, off, waiting for rewrite)*/
    int aof_fsync;                  /* fsync policy */
    sds aof_buf;                    /* AOF buffer */
    time_t aof_flush_postponed_start; /* AOF delayed flush UNIX timestamp */
}
```

### Append Commands

Whenever a command is successfully executed, it is written to the AOF cache through the following call chain: 
> processCommand -> call -> propagate -> feedAppendOnlyFile:

```c
void feedAppendOnlyFile(struct redisCommand *cmd, int dictid, robj **argv, int argc) {
    // Append the command to the end of the buffer and write it to the AOF file before returning the result to the client
    if (server.aof_state == AOF_ON)
        server.aof_buf = sdscatlen(server.aof_buf,buf,sdslen(buf));

     // If a child thread is performing AOF rewrite, it will record the newly added modifications to a new AOF log during this period
    if (server.aof_child_pid != -1)
        aofRewriteBufferAppend((unsigned char*)buf,sdslen(buf));
}
```

### Log Flushing

Before the `serverCron` event loop ends, `flushAppendOnlyFile` is called to write the commands in the buffer to the AOF log file:

```c
int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) {
    // ...
    // AOF delayed flush: Execute fsync once per cron loop
    if (server.aof_flush_postponed_start) flushAppendOnlyFile(0);
}

void flushAppendOnlyFile(int force) {
    ssize_t nwritten;
    int sync_in_progress = 0;

    if (sdslen(server.aof_buf) == 0) { // Return directly if the buffer is empty
        // ...
        return;
    }

    // Write the commands to the AOF file, but not yet flushed
    nwritten = aofWrite(server.aof_fd,server.aof_buf,sdslen(server.aof_buf));
    
    server.aof_flush_postponed_start = 0; // Write completed, reset delayed flush timestamp to avoid triggering again

    // ...

    if (server.aof_fsync == AOF_FSYNC_ALWAYS) {
        // If the flushing policy is always, then fsync immediately
        redis_fsync(server.aof_fd);
        server.aof_fsync_offset = server.aof_current_size;
        server.aof_last_fsync = server.unixtime;
    } else if ((server.aof_fsync == AOF_FSYNC_EVERYSEC &&
                server.unixtime > server.aof_last_fsync)) { 
        // If the flushing policy is everysec, fsync is done asynchronously by a background process
        if (!sync_in_progress) {
            aof_background_fsync(server.aof_fd);
            server.aof_fsync_offset = server.aof_current_size;
        }
        server.aof_last_fsync = server.unixtime;
    }
}
```
It's worth noting that if an error occurs during writing to the AOF file and the persistence strategy is always, the Redis process will exit directly.

### Log Rewriting

As commands are continuously received, the AOF file grows larger, leading to the following issues:

- File systems have limitations on file size, unable to store excessively large files.
- During failure recovery, executing commands from the AOF log one by one can be very slow if the log file is too large.

One significant reason for this problem is the existence of **redundant commands**:

```bash
# Executing commands
127.0.0.1:6379> INCR counter
(integer) 1
127.0.0.1:6379> INCR counter
(integer) 2
127.0.0.1:6379> INCR counter
(integer) 3

# Corresponding AOF log
*2\r\n$6\r\nSELECT\r\n$1\r\n0\r\n
*2\r\n$4\r\nINCR\r\n$7\r\ncounter\r\n
*2\r\n$4\r\nINCR\r\n$7\r\ncounter\r\n
*2\r\n$4\r\nINCR\r\n$7\r\ncounter\r\n
```

Redis provides a **rewrite mechanism** which significantly reduces unnecessary redundant commands:

```bash
# Rewrite the log and output it to a new file
127.0.0.1:6379> BGREWRITEAOF

# After rewriting, 3 INCR commands reduce to 1 SET command
*2\r\n$6\r\nSELECT\r\n$1\r\n0\r\n
*3\r\n$3\r\nSET\r\n$7\r\ncounter\r\n$1\r\n3
```

In addition to manually executing the `BGREWRITEAOF` command, Redis also supports automatic triggering of AOF rewriting. 

The following configuration options can control this behavior:
```bash
# Rewrite strategy
no-appendfsync-on-rewrite no    # Disable fsync during AOF rewriting
auto-aof-rewrite-percentage 100 # Trigger AOF rewriting when the growth percentage exceeds this value
auto-aof-rewrite-min-size 64mb  # Trigger AOF rewriting when the log file size exceeds this value
```

```c
struct redisServer {
    // ...
    int aof_no_fsync_on_rewrite;    /* Disable fsync during AOF rewriting */
    int aof_rewrite_perc;           /* Growth percentage to trigger AOF rewriting */
    off_t aof_rewrite_min_size;     /* Minimum size to trigger AOF rewriting */
    int aof_rewrite_scheduled;      /* Indicates whether a rewrite operation is waiting for BGSAVE to complete */
    list *aof_rewrite_buf_blocks;   /* AOF rewrite buffer */
}
```

Periodic task `serverCron` periodically checks whether the conditions for rewriting are met:
```c
int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) {
    
    /*
      Delayed rewrite: if no background processes are running and BGWRITEAOF command is received,
      delay it until BGSAVE is completed to avoid contention for disk I/O resources
    */
    if (!hasActiveChildProcess() &&   // No child processes performing background operations, indicating BGSAVE has completed
        server.aof_rewrite_scheduled) // There is a BGWRITEAOF command waiting to be executed
    {
        rewriteAppendOnlyFileBackground();
    }
    
    // ...

    if (server.aof_state == AOF_ON && 
        server.aof_rewrite_perc && 
        server.aof_current_size > server.aof_rewrite_min_size) // Check if the log size meets the criteria
    {
        // Check if the growth percentage meets the criteria
        long long base = server.aof_rewrite_base_size ?
            server.aof_rewrite_base_size : 1;
        long long growth = (server.aof_current_size*100/base) - 100;
        if (growth >= server.aof_rewrite_perc) {
            // If the current state meets the rewrite conditions, log and start BGREWRITEAOF
            serverLog(LL_NOTICE,"Starting automatic rewriting of AOF on %lld%% growth",growth);
            rewriteAppendOnlyFileBackground();
        }
    }
}

```
```c
int rewriteAppendOnlyFileBackground(void) {
    // ...
    if ((childpid = redisFork(CHILD_TYPE_AOF)) == 0) {
        /* Child process responsible for rewriting AOF log */
        char tmpfile[256];
        if (rewriteAppendOnlyFile(tmpfile) == C_OK) {
            // ...
        }
    } else {
        /* Main process returns without blocking */
        serverLog(LL_NOTICE,
            "Background append only file rewriting started by pid %d",childpid);
        updateDictResizePolicy();
        return C_OK;
    }
}

```

During rewriting, the main thread continues to serve normally, and database state changes still occur.
However, the AOF rewritten by the child process will not include these changes.

Therefore, these new commands will be appended to both the AOF buffer `server.aof_buf` and the **rewrite buffer** `server.aof_rewrite_buf_blocks` simultaneously. 
Once the rewriting process of the child process is completed, the rewrite buffer is appended to the rewritten AOF log.


Furthermore, to avoid contention with the rewriting process for disk I/O, 
you can disable the main process from calling fsync to persist the AOF log during rewriting by setting **aof_no_fsync_on_rewrite**.


## Comparison

#### RDB Snapshot

- **Pros**: Compact file structure, space-saving, easy to transfer, quick recovery.

- **Cons**: Snapshot generation overhead is only related to the database size; when the database is large, snapshot generation is time-consuming, and frequent operations are not feasible.

#### AAOF Log
- **Pros**: Records changes with fine granularity, minimal pressure on disk I/O, allows frequent persistence, extremely low probability of data loss.

- **Cons**: Slow recovery speed; log recording overhead is related to update frequency, frequent updates can lead to increased disk I/O pressure.
